# Create reset vectors for loop to come
RSCU_phage_reset <- RSCU_phage
RSCU_host_reset <- RSCU_host
# Populate matrix
for(i in 1:nrow(dt_deviate)){
RSCU_host_ith <- RSCU_host[i]
RSCU_phage[i] <- RSCU_host_ith
cos_comparison <- cosine(RSCU_phage, RSCU_host)
print(cos_comparison) #worked
# Store value
dt_deviate[i, 1] <- cos_comparison
# Reset vectors
RSCU_phage <- RSCU_phage_reset
RSCU_host <- RSCU_host_reset
}
# Add a codon and an amino acids in the dataframe
dt_deviate <- as.data.frame(dt_deviate)
dt_deviate["codon"] <- rownames(dt_deviate)
dt_deviate["aa"] <- NA
for(i in 1:nrow(dt_deviate)){
curr_codon <- dt_deviate$codon[i]
amino_acid <- as.character(dt_aa_to_codon$AA[which(dt_aa_to_codon$codon == curr_codon)])
dt_deviate$aa[i] <- amino_acid
}
# Return dataframe
return(dt_deviate)
}
# Create new list
list_NCBI_codondeviate <- vector(mode = "list", length = length(list_NCBI_RSCUmat))
names(list_NCBI_codondeviate) <- names(list_NCBI_RSCUmat)
# Populate list
for(i in 1:length(list_NCBI_codondeviate)){
# Retrieve uco matrix
curr_uco_matrix <- list_NCBI_RSCUmat[[i]]
# Create empty list to be stored in the list
temp_list <- vector(mode = "list", length = ncol(curr_uco_matrix) - 1)
for(j in 1:length(temp_list)){
# Run codon deviate
temp_dt <- cb_codon_deviate(curr_uco_matrix, RSCU_phageloc = j + 1, RSCU_hostloc = 1, dt_aa_to_codon = dt_aa_codon)
temp_dt["Org"] <- colnames(curr_uco_matrix)[j + 1]
# Store result in list
temp_list[[j]] <- temp_dt
}
list_NCBI_codondeviate[[i]] <- temp_list
}
# Create list
list_NCBI_codondiff <- list_NCBI_codondeviate
# Populate list
for(i in 1:length(list_NCBI_codondiff)){
# Retrieve ith list
curr_list <- list_NCBI_codondiff[[i]]
# Retrieve cosine similarity dt
curr_dt_cosinesim <- list_NCBI_cos[[i]]
# Create temporary list to hold dt
temp_list <- vector(mode = "list", length = length(curr_list))
# Retrieve each dt within the list
for(j in 1:length(curr_list)){
# Retrieve original cosine similarity
orig_cos <- curr_dt_cosinesim[1, j]
# Retrieve jth dt
curr_dt <- curr_list[[j]]
# Compute difference
diff <- as.numeric(orig_cos) - curr_dt$V1
# Store value
curr_dt$V1 <- diff
# Store dt in list
curr_list[[j]] <- curr_dt
}
combined_dt <- do.call(rbind, curr_list)
list_NCBI_codondiff[[i]] <- combined_dt
}
# Chunk 36
# Combine all the dataframes into one
NCBI_final_dt <- do.call(rbind, list_NCBI_codondiff)
names(NCBI_final_dt)[names(NCBI_final_dt) == 'Org'] <- 'PhageAcc'
# Chunk 37
# Add column
NCBI_final_dt["PhageFamily"] <- NA
# Populate new column
for(i in 1:nrow(NCBI_final_dt)){
# Current phage
curr_phage <- NCBI_final_dt$PhageAcc[i]
# Subset metadata
temp_dt <- dt_metadata_cb[which(dt_metadata_cb$accession == curr_phage), ]
# Retrieve phage family
NCBI_final_dt$PhageFamily[i] <- temp_dt$family
}
# Chunk 38
ggplot(data = NCBI_final_dt, mapping = aes(x = PhageFamily, y = abs(V1))) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1))
# Chunk 39
# Create dummy column for plotting purposes
NCBI_final_dt["AllOrg"] <- "All"
# Subset by Caudo
NCBI_final_dt_caudo <- NCBI_final_dt[which(NCBI_final_dt$PhageFamily == "Podoviridae" | NCBI_final_dt$PhageFamily == "Siphoviridae" | NCBI_final_dt$PhageFamily == "Myoviridae"), ]
# Plot
ggplot(data = NCBI_final_dt_caudo, mapping = aes(x = PhageFamily, y = abs(V1))) +
geom_boxplot() +
geom_boxplot(data = Helgoland_RSCU_comparison_diff, mapping = aes(x = Org, y = abs(V1))) +
geom_boxplot(data = NCBI_final_dt, aes(x = AllOrg, y = abs(V1))) +
scale_y_log10() +
theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1))
# Create subsets
subset_myo <- NCBI_final_dt[which(NCBI_final_dt$PhageFamily == "Myoviridae"), ]
subset_podo <- NCBI_final_dt[which(NCBI_final_dt$PhageFamily == "Podoviridae"), ]
subset_sipho <- NCBI_final_dt[which(NCBI_final_dt$PhageFamily == "Siphoviridae"), ]
subset_HP1 <- Helgoland_RSCU_comparison_diff[which(Helgoland_RSCU_comparison_diff$Org == "HP1"), ]
subset_HS2 <- Helgoland_RSCU_comparison_diff[which(Helgoland_RSCU_comparison_diff$Org == "HS2"), ]
# Statistical test
ttest_HP1_all <- wilcox.test(NCBI_final_dt$V1, subset_HP1$V1)
ttest_HP1_myo <- wilcox.test(subset_myo$V1, subset_HP1$V1)
ttest_HP1_podo <- wilcox.test(subset_podo$V1, subset_HP1$V1)
ttest_HP1_sipho <- wilcox.test(subset_sipho$V1, subset_HP1$V1)
ttest_HS2_all <- wilcox.test(NCBI_final_dt$V1, subset_HS2$V1)
ttest_HS2_myo <- wilcox.test(subset_myo$V1, subset_HS2$V1)
ttest_HS2_podo <- wilcox.test(subset_podo$V1, subset_HS2$V1)
ttest_HS2_sipho <- wilcox.test(subset_sipho$V1, subset_HS2$V1)
ttest_HP1_HS2 <- wilcox.test(subset_HS2$V1, subset_HP1$V1)
ttest_myo_podo <- wilcox.test(subset_myo$V1, subset_podo$V1)
ttest_myo_sipho <- wilcox.test(subset_myo$V1, subset_sipho$V1)
ttest_podo_sipho <- wilcox.test(subset_podo$V1, subset_sipho$V1)
ttest_myo_all <- wilcox.test(subset_myo$V1, NCBI_final_dt$V1)
ttest_sipho_all <- wilcox.test(subset_sipho$V1, NCBI_final_dt$V1)
ttest_podo_all <- wilcox.test(subset_sipho$V1, NCBI_final_dt$V1)
print(ttest_HP1_all)
print(ttest_HP1_myo)
print(ttest_HP1_podo)
print(ttest_HP1_sipho)
print(ttest_HS2_all)
print(ttest_HS2_myo)
print(ttest_HS2_podo)
print(ttest_HS2_sipho)
print(ttest_HP1_HS2)
print(ttest_myo_podo)
print(ttest_myo_sipho)
print(ttest_podo_sipho)
print(ttest_myo_all)
print(ttest_sipho_all)
print(ttest_podo_all)
View(subset_HP1)
dt_aa_codon
dim(dt_aa_codon)
codon64_vec <- dt_aa_codon$codon
codon64_vec
codon64_vec <- as.vector(dt_aa_codon$codon)
codon64_vec
for(xx in 1:iteration){
cat("Current iterations is:", xx, "\n")
### 1
# Create empty dataframe
dt_codon_values <- data.frame(matrix(ncol = 7, nrow = 64))
colnames(dt_codon_values) <- c("Myo", "Podo", "Sipho", "All", "HS2", "HP1", "Codon")
# The codon, HS2, and HP1 columns will always be the same. Let's get the values in for those columns
dt_codon_values$Codon <- codon64_vec
dt_codon_values$HS2 <- subset_HS2$V1
dt_codon_values$HP1 <- subset_HP1$V1
# Now we need to fill the rest. I will sample random values across phage accession (but not random for the codon)
list_dt <- list(reformatted_myo, reformatted_podo, reformatted_sipho, reformatted_all)
names(list_dt) <- c("Myo", "Podo", "Sipho", "All")
numb_per_category <- c(ncol(reformatted_myo), ncol(reformatted_podo), ncol(reformatted_sipho), ncol(reformatted_all))
for(i in 1:length(col_of_dt)){
# Retrieve relevant dataframe (based on phage family or all)
name_subset <- col_of_dt[i]
curr_dt <- list_dt[[name_subset]]
# Create possible sample vector
ncol_of_dt <- c(1:ncol(curr_dt))
cat("Sample size is:", length(ncol_of_dt), "\n")
for(j in 1:nrow(dt_codon_values)){
# Retrieve relevant row and make it into a vector
values_vector <- as.vector(curr_dt[j, ])
# Get a random value from each row of the curr_dt and store in the dt_codon_values
random_number <- sample(ncol_of_dt, 1)
temp_value <- values_vector[random_number]
#print(temp_value) #looks right to me!
# Store value
dt_codon_values[j, i] <- temp_value
}
}
#head(dt_codon_values)
### 2
melted_dt_codon_values <- melt(dt_codon_values)
colnames(melted_dt_codon_values) <- c("Codon", "Org", "V1")
### 3
stat_test <- pairwise.t.test(melted_dt_codon_values$V1, melted_dt_codon_values$Org)
#print(stat_test)
mymat <- stat_test[[3]]
#print(mymat)
### 4
# Store values from section 3
# Ill store as vectors, and we should be able to rbind the vectors later on
pairname_vec <- c("HS2-HP1", "HS2_All", "HS2_Myo", "HS2_Podo", "HS2_Sipho", "HP1_All", "HP1_Myo", "HP1_Podo", "HP1_Sipho", "Myo_Podo", "Myo_Sipho", "Sipho_Podo", "All_Myo", "All_Podo", "All_Sipho")
stats_pvalues_vec <- c(mymat["HP1", "HS2"], mymat["HS2", "All"], mymat["HS2", "Myo"], mymat["HS2", "Podo"], mymat["HS2", "Sipho"], mymat["HP1", "All"], mymat["HP1", "Myo"], mymat["HP1", "Podo"], mymat["HP1", "Sipho"], mymat["Podo", "Myo"], mymat["Sipho", "Myo"], mymat["Sipho", "Podo"], mymat["All", "Myo"], mymat["All", "Podo"], mymat["All", "Sipho"])
iteration_list[[xx]] <- stats_pvalues_vec
}
iteration <- 1000
iteration_list <- vector(mode = "list", length = iteration)
codon64_vec <- as.vector(dt_aa_codon$codon)
for(xx in 1:iteration){
cat("Current iterations is:", xx, "\n")
### 1
# Create empty dataframe
dt_codon_values <- data.frame(matrix(ncol = 7, nrow = 64))
colnames(dt_codon_values) <- c("Myo", "Podo", "Sipho", "All", "HS2", "HP1", "Codon")
# The codon, HS2, and HP1 columns will always be the same. Let's get the values in for those columns
dt_codon_values$Codon <- codon64_vec
dt_codon_values$HS2 <- subset_HS2$V1
dt_codon_values$HP1 <- subset_HP1$V1
# Now we need to fill the rest. I will sample random values across phage accession (but not random for the codon)
list_dt <- list(reformatted_myo, reformatted_podo, reformatted_sipho, reformatted_all)
names(list_dt) <- c("Myo", "Podo", "Sipho", "All")
numb_per_category <- c(ncol(reformatted_myo), ncol(reformatted_podo), ncol(reformatted_sipho), ncol(reformatted_all))
for(i in 1:length(col_of_dt)){
# Retrieve relevant dataframe (based on phage family or all)
name_subset <- col_of_dt[i]
curr_dt <- list_dt[[name_subset]]
# Create possible sample vector
ncol_of_dt <- c(1:ncol(curr_dt))
cat("Sample size is:", length(ncol_of_dt), "\n")
for(j in 1:nrow(dt_codon_values)){
# Retrieve relevant row and make it into a vector
values_vector <- as.vector(curr_dt[j, ])
# Get a random value from each row of the curr_dt and store in the dt_codon_values
random_number <- sample(ncol_of_dt, 1)
temp_value <- values_vector[random_number]
#print(temp_value) #looks right to me!
# Store value
dt_codon_values[j, i] <- temp_value
}
}
#head(dt_codon_values)
### 2
melted_dt_codon_values <- melt(dt_codon_values)
colnames(melted_dt_codon_values) <- c("Codon", "Org", "V1")
### 3
stat_test <- pairwise.t.test(melted_dt_codon_values$V1, melted_dt_codon_values$Org)
#print(stat_test)
mymat <- stat_test[[3]]
#print(mymat)
### 4
# Store values from section 3
# Ill store as vectors, and we should be able to rbind the vectors later on
pairname_vec <- c("HS2-HP1", "HS2_All", "HS2_Myo", "HS2_Podo", "HS2_Sipho", "HP1_All", "HP1_Myo", "HP1_Podo", "HP1_Sipho", "Myo_Podo", "Myo_Sipho", "Sipho_Podo", "All_Myo", "All_Podo", "All_Sipho")
stats_pvalues_vec <- c(mymat["HP1", "HS2"], mymat["HS2", "All"], mymat["HS2", "Myo"], mymat["HS2", "Podo"], mymat["HS2", "Sipho"], mymat["HP1", "All"], mymat["HP1", "Myo"], mymat["HP1", "Podo"], mymat["HP1", "Sipho"], mymat["Podo", "Myo"], mymat["Sipho", "Myo"], mymat["Sipho", "Podo"], mymat["All", "Myo"], mymat["All", "Podo"], mymat["All", "Sipho"])
iteration_list[[xx]] <- stats_pvalues_vec
}
iteration <- 1000
iteration_list <- vector(mode = "list", length = iteration)
codon64_vec <- dt_aa_codon$codon
for(xx in 1:iteration){
cat("Current iterations is:", xx, "\n")
### 1
# Create empty dataframe
dt_codon_values <- data.frame(matrix(ncol = 7, nrow = 64))
colnames(dt_codon_values) <- c("Myo", "Podo", "Sipho", "All", "HS2", "HP1", "Codon")
# The codon, HS2, and HP1 columns will always be the same. Let's get the values in for those columns
dt_codon_values$Codon <- codon64_vec
dt_codon_values$HS2 <- subset_HS2$V1
dt_codon_values$HP1 <- subset_HP1$V1
# Now we need to fill the rest. I will sample random values across phage accession (but not random for the codon)
list_dt <- list(reformatted_myo, reformatted_podo, reformatted_sipho, reformatted_all)
names(list_dt) <- c("Myo", "Podo", "Sipho", "All")
numb_per_category <- c(ncol(reformatted_myo), ncol(reformatted_podo), ncol(reformatted_sipho), ncol(reformatted_all))
for(i in 1:length(col_of_dt)){
# Retrieve relevant dataframe (based on phage family or all)
name_subset <- col_of_dt[i]
curr_dt <- list_dt[[name_subset]]
# Create possible sample vector
ncol_of_dt <- c(1:ncol(curr_dt))
cat("Sample size is:", length(ncol_of_dt), "\n")
for(j in 1:nrow(dt_codon_values)){
# Retrieve relevant row and make it into a vector
values_vector <- as.vector(curr_dt[j, ])
# Get a random value from each row of the curr_dt and store in the dt_codon_values
random_number <- sample(ncol_of_dt, 1)
temp_value <- values_vector[random_number]
#print(temp_value) #looks right to me!
# Store value
dt_codon_values[j, i] <- temp_value
}
}
#head(dt_codon_values)
### 2
melted_dt_codon_values <- melt(dt_codon_values)
colnames(melted_dt_codon_values) <- c("Codon", "Org", "V1")
### 3
stat_test <- pairwise.t.test(melted_dt_codon_values$V1, melted_dt_codon_values$Org)
#print(stat_test)
mymat <- stat_test[[3]]
#print(mymat)
### 4
# Store values from section 3
# Ill store as vectors, and we should be able to rbind the vectors later on
pairname_vec <- c("HS2-HP1", "HS2_All", "HS2_Myo", "HS2_Podo", "HS2_Sipho", "HP1_All", "HP1_Myo", "HP1_Podo", "HP1_Sipho", "Myo_Podo", "Myo_Sipho", "Sipho_Podo", "All_Myo", "All_Podo", "All_Sipho")
stats_pvalues_vec <- c(mymat["HP1", "HS2"], mymat["HS2", "All"], mymat["HS2", "Myo"], mymat["HS2", "Podo"], mymat["HS2", "Sipho"], mymat["HP1", "All"], mymat["HP1", "Myo"], mymat["HP1", "Podo"], mymat["HP1", "Sipho"], mymat["Podo", "Myo"], mymat["Sipho", "Myo"], mymat["Sipho", "Podo"], mymat["All", "Myo"], mymat["All", "Podo"], mymat["All", "Sipho"])
iteration_list[[xx]] <- stats_pvalues_vec
}
codon64_vec <- NCBI_final_dt$codon[0:64]
# Create empty dataframe
reformatted_myo <- data.frame(matrix(nrow = 64, ncol = length(unique(subset_myo$PhageAcc))))
rownames(reformatted_myo) <- codon64_vec
colnames(reformatted_myo) <- unique(subset_myo$PhageAcc)
# Populate dataframe
for(i in 1:ncol(reformatted_myo)){
# Get phage acc
curr_phage <- colnames(reformatted_myo)[i]
# Retrieve values
vec_value <- subset_myo$V1[which(subset_myo$PhageAcc == curr_phage)]
# Store values
reformatted_myo[, i] <- vec_value
}
# Create empty dataframe
reformatted_podo <- data.frame(matrix(nrow = 64, ncol = length(unique(subset_podo$PhageAcc))))
rownames(reformatted_podo) <- codon64_vec
colnames(reformatted_podo) <- unique(subset_podo$PhageAcc)
# Populate dataframe
for(i in 1:ncol(reformatted_podo)){
# Get phage acc
curr_phage <- colnames(reformatted_podo)[i]
# Retrieve values
vec_value <- subset_podo$V1[which(subset_podo$PhageAcc == curr_phage)]
# Store values
reformatted_podo[, i] <- vec_value
}
# Create empty dataframe
reformatted_sipho <- data.frame(matrix(nrow = 64, ncol = length(unique(subset_sipho$PhageAcc))))
rownames(reformatted_sipho) <- codon64_vec
colnames(reformatted_sipho) <- unique(subset_sipho$PhageAcc)
# Populate dataframe
for(i in 1:ncol(reformatted_sipho)){
# Get phage acc
curr_phage <- colnames(reformatted_sipho)[i]
# Retrieve values
vec_value <- subset_sipho$V1[which(subset_sipho$PhageAcc == curr_phage)]
# Store values
reformatted_sipho[, i] <- vec_value
}
# Create empty dataframe
reformatted_all <- data.frame(matrix(nrow = 64, ncol = length(unique(NCBI_final_dt$PhageAcc))))
rownames(reformatted_all) <- codon64_vec
colnames(reformatted_all) <- unique(NCBI_final_dt$PhageAcc)
# Populate dataframe
for(i in 1:ncol(reformatted_all)){
# Get phage acc
curr_phage <- colnames(reformatted_all)[i]
# Retrieve values
vec_value <- NCBI_final_dt$V1[which(NCBI_final_dt$PhageAcc == curr_phage)]
# Store values
reformatted_all[, i] <- vec_value
}
ncol_of_dt <- c(1:ncol(reformatted_myo))
sample(ncol_of_dt, 1)
iteration <- 1000
iteration_list <- vector(mode = "list", length = iteration)
for(xx in 1:iteration){
cat("Current iterations is:", xx, "\n")
### 1
# Create empty dataframe
dt_codon_values <- data.frame(matrix(ncol = 7, nrow = 64))
colnames(dt_codon_values) <- c("Myo", "Podo", "Sipho", "All", "HS2", "HP1", "Codon")
# The codon, HS2, and HP1 columns will always be the same. Let's get the values in for those columns
dt_codon_values$Codon <- codon64_vec
dt_codon_values$HS2 <- subset_HS2$V1
dt_codon_values$HP1 <- subset_HP1$V1
# Now we need to fill the rest. I will sample random values across phage accession (but not random for the codon)
list_dt <- list(reformatted_myo, reformatted_podo, reformatted_sipho, reformatted_all)
names(list_dt) <- c("Myo", "Podo", "Sipho", "All")
numb_per_category <- c(ncol(reformatted_myo), ncol(reformatted_podo), ncol(reformatted_sipho), ncol(reformatted_all))
for(i in 1:length(col_of_dt)){
# Retrieve relevant dataframe (based on phage family or all)
name_subset <- col_of_dt[i]
curr_dt <- list_dt[[name_subset]]
# Create possible sample vector
ncol_of_dt <- c(1:ncol(curr_dt))
cat("Sample size is:", length(ncol_of_dt), "\n")
for(j in 1:nrow(dt_codon_values)){
# Retrieve relevant row and make it into a vector
values_vector <- as.vector(curr_dt[j, ])
# Get a random value from each row of the curr_dt and store in the dt_codon_values
random_number <- sample(ncol_of_dt, 1)
temp_value <- values_vector[random_number]
#print(temp_value) #looks right to me!
# Store value
dt_codon_values[j, i] <- temp_value
}
}
#head(dt_codon_values)
### 2
melted_dt_codon_values <- melt(dt_codon_values)
colnames(melted_dt_codon_values) <- c("Codon", "Org", "V1")
### 3
stat_test <- pairwise.t.test(melted_dt_codon_values$V1, melted_dt_codon_values$Org)
#print(stat_test)
mymat <- stat_test[[3]]
#print(mymat)
### 4
# Store values from section 3
# Ill store as vectors, and we should be able to rbind the vectors later on
pairname_vec <- c("HS2-HP1", "HS2_All", "HS2_Myo", "HS2_Podo", "HS2_Sipho", "HP1_All", "HP1_Myo", "HP1_Podo", "HP1_Sipho", "Myo_Podo", "Myo_Sipho", "Sipho_Podo", "All_Myo", "All_Podo", "All_Sipho")
stats_pvalues_vec <- c(mymat["HP1", "HS2"], mymat["HS2", "All"], mymat["HS2", "Myo"], mymat["HS2", "Podo"], mymat["HS2", "Sipho"], mymat["HP1", "All"], mymat["HP1", "Myo"], mymat["HP1", "Podo"], mymat["HP1", "Sipho"], mymat["Podo", "Myo"], mymat["Sipho", "Myo"], mymat["Sipho", "Podo"], mymat["All", "Myo"], mymat["All", "Podo"], mymat["All", "Sipho"])
iteration_list[[xx]] <- stats_pvalues_vec
}
iteration_stat_dt <- as.data.frame(do.call(rbind, iteration_list))
colnames(iteration_stat_dt) <- pairname_vec
iteration_number_vec <- c(1:iteration)
iteration_stat_dt["IterationNumber"] <- iteration_number_vec
iteration <- 1000
iteration_list <- vector(mode = "list", length = iteration)
for(xx in 1:iteration){
cat("Current iterations is:", xx, "\n")
### 1
# Create empty dataframe
dt_codon_values <- data.frame(matrix(ncol = 7, nrow = 64))
colnames(dt_codon_values) <- c("Myo", "Podo", "Sipho", "All", "HS2", "HP1", "Codon")
# The codon, HS2, and HP1 columns will always be the same. Let's get the values in for those columns
dt_codon_values$Codon <- codon64_vec
dt_codon_values$HS2 <- subset_HS2$V1
dt_codon_values$HP1 <- subset_HP1$V1
# Now we need to fill the rest. I will sample random values across phage accession (but not random for the codon)
list_dt <- list(reformatted_myo, reformatted_podo, reformatted_sipho, reformatted_all)
names(list_dt) <- c("Myo", "Podo", "Sipho", "All")
numb_per_category <- c(ncol(reformatted_myo), ncol(reformatted_podo), ncol(reformatted_sipho), ncol(reformatted_all))
for(i in 1:length(col_of_dt)){
# Retrieve relevant dataframe (based on phage family or all)
name_subset <- col_of_dt[i]
curr_dt <- list_dt[[name_subset]]
# Create possible sample vector
ncol_of_dt <- c(1:ncol(curr_dt))
cat("Sample size is:", length(ncol_of_dt), "\n")
for(j in 1:nrow(dt_codon_values)){
# Retrieve relevant row and make it into a vector
values_vector <- as.vector(curr_dt[j, ])
# Get a random value from each row of the curr_dt and store in the dt_codon_values
random_number <- sample(ncol_of_dt, 1)
temp_value <- values_vector[random_number]
#print(temp_value) #looks right to me!
# Store value
dt_codon_values[j, i] <- temp_value
}
}
#head(dt_codon_values)
### 2
melted_dt_codon_values <- melt(dt_codon_values)
colnames(melted_dt_codon_values) <- c("Codon", "Org", "V1")
### 3
stat_test <- pairwise.t.test(melted_dt_codon_values$V1, melted_dt_codon_values$Org)
#print(stat_test)
mymat <- stat_test[[3]]
#print(mymat)
### 4
# Store values from section 3
# Ill store as vectors, and we should be able to rbind the vectors later on
pairname_vec <- c("HS2-HP1", "HS2_All", "HS2_Myo", "HS2_Podo", "HS2_Sipho", "HP1_All", "HP1_Myo", "HP1_Podo", "HP1_Sipho", "Myo_Podo", "Myo_Sipho", "Sipho_Podo", "All_Myo", "All_Podo", "All_Sipho")
stats_pvalues_vec <- c(mymat["HP1", "HS2"], mymat["HS2", "All"], mymat["HS2", "Myo"], mymat["HS2", "Podo"], mymat["HS2", "Sipho"], mymat["HP1", "All"], mymat["HP1", "Myo"], mymat["HP1", "Podo"], mymat["HP1", "Sipho"], mymat["Podo", "Myo"], mymat["Sipho", "Myo"], mymat["Sipho", "Podo"], mymat["All", "Myo"], mymat["All", "Podo"], mymat["All", "Sipho"])
iteration_list[[xx]] <- stats_pvalues_vec
}
iteration_stat_dt <- as.data.frame(do.call(rbind, iteration_list))
iteration <- 1000
iteration_list <- vector(mode = "list", length = iteration)
# Now we need to fill the rest. I will sample random values across phage accession (but not random for the codon)
list_dt <- list(reformatted_myo, reformatted_podo, reformatted_sipho, reformatted_all)
names(list_dt) <- c("Myo", "Podo", "Sipho", "All")
col_of_dt <- c("Myo", "Podo", "Sipho", "All")
for(xx in 1:iteration){
cat("Current iterations is:", xx, "\n")
### 1
# Create empty dataframe
dt_codon_values <- data.frame(matrix(ncol = 7, nrow = 64))
colnames(dt_codon_values) <- c("Myo", "Podo", "Sipho", "All", "HS2", "HP1", "Codon")
# The codon, HS2, and HP1 columns will always be the same. Let's get the values in for those columns
dt_codon_values$Codon <- codon64_vec
dt_codon_values$HS2 <- subset_HS2$V1
dt_codon_values$HP1 <- subset_HP1$V1
# Now we need to fill the rest. I will sample random values across phage accession (but not random for the codon)
list_dt <- list(reformatted_myo, reformatted_podo, reformatted_sipho, reformatted_all)
names(list_dt) <- c("Myo", "Podo", "Sipho", "All")
numb_per_category <- c(ncol(reformatted_myo), ncol(reformatted_podo), ncol(reformatted_sipho), ncol(reformatted_all))
for(i in 1:length(col_of_dt)){
# Retrieve relevant dataframe (based on phage family or all)
name_subset <- col_of_dt[i]
curr_dt <- list_dt[[name_subset]]
# Create possible sample vector
ncol_of_dt <- c(1:ncol(curr_dt))
cat("Sample size is:", length(ncol_of_dt), "\n")
for(j in 1:nrow(dt_codon_values)){
# Retrieve relevant row and make it into a vector
values_vector <- as.vector(curr_dt[j, ])
# Get a random value from each row of the curr_dt and store in the dt_codon_values
random_number <- sample(ncol_of_dt, 1)
temp_value <- values_vector[random_number]
#print(temp_value) #looks right to me!
# Store value
dt_codon_values[j, i] <- temp_value
}
}
#head(dt_codon_values)
### 2
melted_dt_codon_values <- melt(dt_codon_values)
colnames(melted_dt_codon_values) <- c("Codon", "Org", "V1")
### 3
stat_test <- pairwise.t.test(melted_dt_codon_values$V1, melted_dt_codon_values$Org)
#print(stat_test)
mymat <- stat_test[[3]]
#print(mymat)
### 4
# Store values from section 3
# Ill store as vectors, and we should be able to rbind the vectors later on
pairname_vec <- c("HS2-HP1", "HS2_All", "HS2_Myo", "HS2_Podo", "HS2_Sipho", "HP1_All", "HP1_Myo", "HP1_Podo", "HP1_Sipho", "Myo_Podo", "Myo_Sipho", "Sipho_Podo", "All_Myo", "All_Podo", "All_Sipho")
stats_pvalues_vec <- c(mymat["HP1", "HS2"], mymat["HS2", "All"], mymat["HS2", "Myo"], mymat["HS2", "Podo"], mymat["HS2", "Sipho"], mymat["HP1", "All"], mymat["HP1", "Myo"], mymat["HP1", "Podo"], mymat["HP1", "Sipho"], mymat["Podo", "Myo"], mymat["Sipho", "Myo"], mymat["Sipho", "Podo"], mymat["All", "Myo"], mymat["All", "Podo"], mymat["All", "Sipho"])
iteration_list[[xx]] <- stats_pvalues_vec
}
source('~/.active-rstudio-document', echo=TRUE)
